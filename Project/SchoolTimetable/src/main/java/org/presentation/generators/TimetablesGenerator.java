package org.presentation.generators;

import jakarta.validation.constraints.Min;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import org.domain.models.*;
import org.presentation.GUI;

import java.text.SimpleDateFormat;
import java.util.*;
import java.util.Objects;


/**
 * The TimetablesGenerator is a class that extends the BaseGenerator class and is responsible for generating timetables based on provided data.
 * It contains methods to initialize free rooms, create timetable data for days, extract teachers and groups for timetables,
 * add elements to a timetable entry, add an entry to tables, add availability information to the free rooms table,
 * generate timetables from timeslots, and generate the complete timetable.
 * This class provides functionality to generate timetables for different entities from database.
 * The generated timetables are stored in data structures and can be accessed and used for further processing or display.
 */
public class TimetablesGenerator extends BaseGenerator{
    @NotNull(message = "Timeslots list must not be null")
    private final List<@Valid Timeslot> timeslots;
    @NotNull(message = "Rooms list must not be null")
    private final List<@Valid Room> rooms;
    @NotNull(message = "Timetables names map must not be null")
    private final Map<String, String> timetablesNames;
    @NotNull(message = "Timetables data map must not be null")
    private final Map<String, String> timetablesData;
    @NotNull(message = "Free rooms map must not be null")
    private final Map<Room, Map<Integer, Map<Timeslot.Day, Boolean>>> freeRooms;

    /**
     * Constructs a TimetablesGenerator object with the specified generation date string, timetables days data, timetables names map, timetables data map, and free rooms map.
     *
     * @param generationDateString The generation date string to be displayed on the page. Must not be blank.
     * @param timetablesDays       The map containing the timetable data organized by table names and days. Must not be null.
     * @param timetablesNames      The map containing the timetable title organized by table names. Must not be null.
     * @param timetablesData       The map containing the timetable data organized by table names. Must not be null.
     * @param freeRooms            The map containing the free rooms organized by days and hours. Must not be null.
     */
    public TimetablesGenerator(
            @NotBlank(message = "Generation string must not be blank")
            String generationDateString,
            @NotNull(message = "Days data map must not be null")
            Map<String, Map<Timeslot.Day, StringBuilder>> timetablesDays,
            @NotNull(message = "Timetables names map must not be null")
            Map<String, String> timetablesNames,
            @NotNull(message = "Timetables data map must not be null")
            Map<String, String> timetablesData,
            @NotNull(message = "Free rooms map must not be null")
            Map<Room, Map<Integer, Map<Timeslot.Day, Boolean>>> freeRooms){
        super(generationDateString, timetablesDays);

        this.timeslots = GUI.app.timeslotsService.getSortedTimeslotsByStartTime();
        this.rooms = GUI.app.roomsService.getRooms();
        this.timetablesNames = timetablesNames;
        this.timetablesData = timetablesData;
        this.freeRooms = freeRooms;
    }

    /**
     * Initializes the map of free rooms with their availability for each timeslot and day.
     * The availability is initially set to true for all timeslots and days.
     */
    private void initializeFreeRooms(){
        Timeslot.Day[] daysArray = Timeslot.Day.class.getEnumConstants();

        for (Room room : rooms){
            Map<Integer, Map<Timeslot.Day, Boolean>> hoursMap = new HashMap<>();
            for (int i = 8; i < 20; i++) {
                Map<Timeslot.Day, Boolean> dayMap = new HashMap<>();
                for (Timeslot.Day day : daysArray){
                    dayMap.put(day, true);
                }
                hoursMap.put(i, dayMap);
            }
            freeRooms.put(room, hoursMap);
        }
    }

    /**
     * Creates the timetable data for each timetable based on the days data.
     * The days data contains the schedule information for each day of the week.
     * The timetable data is generated by replacing placeholders in the base template with the actual day data.
     * The generated timetable data is stored in the timetablesData map.
     */
    private void createTimetableDataFromDays(){
        for (Map.Entry<String, Map<Timeslot.Day, StringBuilder>> mapEntry : this.timetablesDays.entrySet()){
            String tableName = mapEntry.getKey();
            Map<Timeslot.Day, StringBuilder> daysData = mapEntry.getValue();

            String timetableEntry = utils.getBaseTemplateData("timetable");
            timetableEntry = timetableEntry.replace("$generation_date", this.generationDateString);
            timetableEntry = timetableEntry.replace("$title", this.timetablesNames.get(tableName));

            for (Map.Entry<Timeslot.Day, StringBuilder> dayEntry : daysData.entrySet()){
                String dayName = dayEntry.getKey().name().toLowerCase();
                String dayData = dayEntry.getValue().toString();

                timetableEntry = timetableEntry.replace("$" + dayName + "_elements", dayData);
            }

            this.timetablesData.put(tableName, timetableEntry);
        }
    }

    /**
     * Extracts the teachers' data for generating timetables.
     * The method takes a set of teachers, a list of table names, and a map for storing teacher names and their respective timetable names.
     * For each teacher, it retrieves the teacher's name and generates a corresponding timetable name.
     * The timetable name is added to the list of table names, and the teacher name is mapped to the timetable name in the teacherNamesTables map.
     *
     * @param teachers            A set of teachers for which the timetable data will be extracted.
     * @param tableNames          A list to store the generated timetable names.
     * @param teacherNamesTables  A map to store the mapping between teacher names and their respective timetable names.
     */
    private void extractTeachersForTimetable(
            @NotNull(message = "Teachers set must not be null")
            Set<@Valid Teacher> teachers,
            @NotEmpty(message = "Table names list must not be empty")
            List<String> tableNames,
            @NotNull(message = "Teachers names map must not be null")
            Map<String, String> teacherNamesTables){
        for (Teacher teacher : teachers){
            String teacherName = Objects.requireNonNull(teacher.getName(), "Teacher name should not be null.");
            String timetableName = "timetable_t_" + teacherName.toLowerCase().replace(" ", "_");
            tableNames.add(timetableName);

            if (teacher.getType() == Teacher.Type.TEACHER) teacherName = "Prof. " + teacherName;
            else if (teacher.getType() == Teacher.Type.COLLABORATOR) teacherName = "Collab. " + teacherName;
            teacherNamesTables.put(teacherName, timetableName);
        }
    }

    /**
     * Extracts the student groups' data for generating timetables.
     * The method takes a set of student groups, a list of table names, and a map for storing group names and their respective timetable names.
     * For each student group, it retrieves the group's name and year, and generates a corresponding timetable name.
     * The timetable name is added to the list of table names, and the group name (combined with the year) is mapped to the timetable name in the groupsNamesTables map.
     *
     * @param studentGroups       A set of student groups for which the timetable data will be extracted.
     * @param tableNames          A list to store the generated timetable names.
     * @param groupsNamesTables   A map to store the mapping between group names (combined with the year) and their respective timetable names.
     */
    private void extractGroupsForTimetable(
            @NotNull(message = "Groups set must not be null")
            Set<@Valid StudentGroup> studentGroups,
            @NotEmpty(message = "Table names list must not be empty")
            List<String> tableNames,
            @NotNull(message = "Groups names map must not be null")
            Map<String, String> groupsNamesTables){
        for (StudentGroup studentGroup : studentGroups){
            String groupName = Objects.requireNonNull(studentGroup.getName(), "Group name should not be null.");
            int year = studentGroup.getYear();
            String timetableName = "timetable_g_" + year + groupName.toLowerCase().replace(" ", "_");
            tableNames.add(timetableName);

            groupsNamesTables.put(year + groupName, timetableName);
        }
    }

    /**
     * Adds elements to a timetable entry and returns the updated timetable entry.
     * The method takes an entry name, timetable entry string, a map of element names and their respective table names, and an endline string.
     * It iterates over the element names and table names, and generates an entry for each element using a base template.
     * The generated entries are appended to form a string of all elements.
     * The entry name in the timetable entry string is replaced with the string of all elements.
     * The updated timetable entry is returned.
     *
     * @param name                The name of the entry to be replaced in the timetable entry string.
     * @param timetableEntry      The timetable entry string to which elements will be added.
     * @param elementsNamesTables A map of element names and their respective table names.
     * @param endLine             The endline string used for separating elements in the timetable entry.
     * @return The updated timetable entry string with elements added.
     */
    @NotBlank(message = "Timetable entry string must not be blank")
    private String addElementsToTimetableEntry(
            @NotBlank(message = "Entry name must not be blank")
            String name,
            @NotBlank(message = "Entry data must not be blank")
            String timetableEntry,
            @NotNull(message = "Elements names map must not be null")
            Map<String, String> elementsNamesTables,
            @NotBlank(message = "Endline must not be blank")
            String endLine){
        StringBuilder allElements = new StringBuilder();

        for (Map.Entry<String, String> mapEntry : elementsNamesTables.entrySet()){
            String elementEntry = utils.getBaseTemplateData("atomics" + this.separator + "a_entry");
            String elementName = mapEntry.getKey();
            String elementTable = mapEntry.getValue();

            elementEntry = elementEntry.replace("$entry_ref", "./" + elementTable + ".html");
            elementEntry = elementEntry.replace("$entry_name", elementName);

            allElements.append(elementEntry).append(endLine);
        }

        if (allElements.length() >= endLine.length()) allElements.setLength(allElements.length() - endLine.length());
        timetableEntry = timetableEntry.replace("$entry_" + name, allElements.toString());
        return timetableEntry;
    }

    /**
     * Adds a timetable entry to multiple tables for a specific day.
     * The method takes a timetable entry string, a list of table names, and a day.
     * It iterates over the table names and retrieves the corresponding day's StringBuilder from the timetablesDays map.
     * The timetable entry is appended to the StringBuilder for the specified day in each table.
     *
     * @param timetableEntry The timetable entry data to be added to the tables.
     * @param tableNames     The list of table names to which the timetable entry will be added.
     * @param day            The day for which the timetable entry is added.
     */
    private void addEntryToTables(
            @NotBlank(message = "Timetable entry data must not be blank")
            String timetableEntry,
            @NotEmpty(message = "Table names list must not be empty")
            List<String> tableNames,
            @NotNull(message = "Day must not be null")
            Timeslot.Day day){
        for (String tableName : tableNames){
            this.timetablesDays.get(tableName).get(day).append(timetableEntry);
        }
    }

    /**
     * Updates the availability status of a room in the freeRooms table for a specific day and time range.
     * The method takes a day, a room, a start hour, and an end hour.
     * It iterates over the hours within the specified range and sets the availability status of the room for each hour and day combination to false.
     *
     * @param day       The day for which the room availability is updated.
     * @param room      The room for which the availability status is updated.
     * @param startHour The starting hour of the time range.
     * @param endHour   The ending hour of the time range.
     */
    private void addToFreeRoomsTable(
            @NotNull(message = "Day must not be null")
            Timeslot.Day day,
            @NotNull(message = "Room must not be null")
            Room room,
            @Min(value = 0, message = "Start hour must be greater than -1")
            int startHour,
            @Min(value = 0, message = "End hour must be greater than -1")
            int endHour){
        for (int i = startHour; i < endHour; i++) {
            freeRooms.get(room).get(i).replace(day, false);
        }
    }

    /**
     * Generates timetables based on the provided timeslots.
     * It iterates over each timeslot and extracts the necessary information such as start time, end time,
     * room, discipline, teachers, and student groups. It then processes the information to update the availability
     * status of the room, create table names, and extract teachers and student groups for each timetable.
     * Finally, it generates a timetable entry and adds it to the corresponding tables for the specified day.
     * The method uses SimpleDateFormat to format the dates and times.
     */
    private void generateTimetablesFromTimeslots(){
        for (Timeslot timeslot : this.timeslots) {
            Date startTime = new Date(timeslot.getTime().getTime());
            Date endTime = Date.from(startTime.toInstant().plus(timeslot.getTimespan()));
            Room room = timeslot.getRoom();
            Discipline discipline = timeslot.getSession().getDiscipline();
            Set<Teacher> teachers = timeslot.getSession().getTeachers();
            Set<StudentGroup> studentGroups = timeslot.getSession().getGroups();

            SimpleDateFormat formatter = new SimpleDateFormat("HH:mm");
            String startTimeString = formatter.format(startTime);
            String endTimeString = formatter.format(endTime);

            int startHour = 0;
            int endHour = 0;
            int endMinutes = 0;

            try{
                startHour = Integer.parseInt(startTimeString.substring(0, 2));
                endHour = Integer.parseInt(endTimeString.substring(0, 2));
                endMinutes = Integer.parseInt(endTimeString.substring(3, 5));
            }
            catch (NumberFormatException ex){
                ex.printStackTrace();
            }

            if (endMinutes > 0){
                endHour += 1;
            }

            this.addToFreeRoomsTable(timeslot.getWeekday(), room, startHour, endHour);

            SimpleDateFormat formatter2 = new SimpleDateFormat("dd.MM.yyyy");
            String startDateString = formatter2.format(timeslot.getStartDate());
            String endDateString = formatter2.format(timeslot.getEndDate());

            List<String> tableNames = new ArrayList<>();
            Map<String, String> groupsNamesTables = new HashMap<>();
            Map<String, String> teacherNamesTables = new HashMap<>();

            String disciplineTable = "timetable_d_" + discipline.getName().toLowerCase().replace(" ", "_");
            String roomTable = "timetable_r_" + room.getName().toLowerCase().replace(" ", "_");
            tableNames.add("timetable");
            tableNames.add(disciplineTable);
            tableNames.add(roomTable);

            extractTeachersForTimetable(teachers, tableNames, teacherNamesTables);
            extractGroupsForTimetable(studentGroups, tableNames, groupsNamesTables);

            String timetableEntry = utils.getBaseTemplateData("atomics" + this.separator + "timetable_entry");

            timetableEntry = timetableEntry.replace("$entry_start", startTimeString);
            timetableEntry = timetableEntry.replace("$entry_end", endTimeString);
            timetableEntry = timetableEntry.replace("$discipline_name", discipline.getName());
            timetableEntry = timetableEntry.replace("$discipline_ref", "./" + disciplineTable + ".html");
            timetableEntry = timetableEntry.replace("$entry_type", timeslot.getSession().getType().toString());
            timetableEntry = timetableEntry.replace("$room_name", room.getName());
            timetableEntry = timetableEntry.replace("$room_ref", "./" + roomTable + ".html");
            timetableEntry = timetableEntry.replace("$entry_frequency", timeslot.getPeriodicity().toString());
            timetableEntry = timetableEntry.replace("$entry_period", startDateString + " - " + endDateString);

            timetableEntry = addElementsToTimetableEntry("students", timetableEntry, groupsNamesTables, ", ");
            timetableEntry = addElementsToTimetableEntry("teachers", timetableEntry, teacherNamesTables, "<br>");

            addEntryToTables(timetableEntry, tableNames, timeslot.getWeekday());
        }
    }

    /**
     * Generates the complete timetable by executing the necessary steps in order.
     * It initializes the availability of free rooms using the initializeFreeRooms method.
     * Next, it generates timetables from the provided timeslots using the generateTimetablesFromTimeslots method.
     * Finally, it creates the timetable data from the processed days using the createTimetableDataFromDays method.
     * Overrides the abstract method 'generate' inherited from the BaseGenerator class.
     */
    public void generate(){
        this.addToDaysMap("timetable");
        this.timetablesNames.put("timetable", "Complete Timetable");

        this.initializeFreeRooms();
        this.generateTimetablesFromTimeslots();
        this.createTimetableDataFromDays();
    }
}
